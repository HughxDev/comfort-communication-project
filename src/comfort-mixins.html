<script>
  // (function () {
  'use strict';

  window.Comfort = window.Comfort || {};

  Comfort.PseudoForm = (superclass) => class extends superclass {
    _storeAnswers( event ) {
      function formatResponse( question, questionNumber, selected, selectedNumber ) {
        var response = {};

        response.question = question.question;
        response.number = questionNumber;
        response.type = question.type;
        response.answer = selected;
        response.answer.number = selectedNumber;

        return response;
      }

      // const $form = this.shadowRoot.querySelector( '#pretest-form' );
      const $form = this.shadowRoot.querySelector( 'form' );

      // var values = {};
      var responses = [];

      // console.log( '$form.elements', $form.elements );
      var $element, question, selected, questionXPath;

      for ( var i = 0; i < $form.elements.length; i++ ) {
        $element = $form.elements[i];

        questionXPath = '//d:item[' + parseInt( $element.name, 10 ) + ']';

        question = JSON.search( this.snapshot, questionXPath )[0];

        switch ( $element.type ) {
          case 'radio':
          case 'checkbox':
            if ( $element.checked ) {
              selected = JSON.search( this.snapshot, questionXPath + '/answers[' + $element.value + ']' )[0];
              
              responses.push( formatResponse( question, $element.name, selected, $element.value ) );
            } 
          break;

          default:
            responses.push( formatResponse( question, $element.name, { "text": $element.value, "correct": null }, '1' ) );
        }
      }

      // console.log( 'responses', responses );
      Comfort.User.answers[ document.querySelector( 'comfort-app' ).getAttribute( 'page' ) ] = responses;

      console.log( 'Comfort.User', Comfort.User );

      // event.preventDefault();
    }
  };

  // @todo: subsume into PseudoForm?
  Comfort.InstructorResponses = (superclass) => class extends superclass {
    _revealResponses( event ) {
      const $button = event.target;

      Comfort.scrollY( 0 );

      window.onscroll = () => {
        this.$questions.setAttribute( 'revealed', '' );

        var href = $button.getAttribute( 'data-href' );

        $button.textContent = $button.getAttribute( 'data-after-text' );

        // this.unlisten( $button );
        Polymer.Gestures.removeListener( $button, 'tap' );
      }

      event.preventDefault();
    }
  };

  // @todo: subsume into PseudoForm?
  Comfort.CorrectIncorrect = (superclass) => class extends superclass {
    _markCorrectIncorrectOnInputChange() {
      const $questions = this.shadowRoot.querySelector( '#questions' );
    
      $questions.addEventListener( 'change', event => {
        var input = event.target;
        var questionNumber = input.name;
        var answerNumber = input.value;

        // The question in question: //d:item[1]
        var questionXPath = '//d:item[' + parseInt( questionNumber, 10 ) + ']';

        // Correct answer: //d:item[1]/answers[correct="true"]
        var correct = JSON.search( this.snapshot, questionXPath + '/answers[correct="true"]' )[0];

        // Incorrect answer: //d:item[1]/answers[correct="false"]
        var incorrect = JSON.search( this.snapshot, questionXPath + '/answers[correct="false"]' )[0];
        
        /* Selected answer: //d:item[1]/answers[1] */
        var selected = JSON.search( this.snapshot, questionXPath + '/answers[' + answerNumber + ']' )[0];

        var radio = input;

        while( radio && radio.nodeName.toLowerCase() !== 'comfort-radio' ) { // 11 = DOCUMENT_FRAGMENT_NODE
          radio = radio.parentNode;
        }

        var highlightCorrect = false;

        if ( selected && selected.correct === true ) {
          // alert( 'Correct!' );
          radio.setAttribute( 'correct', '' );
        } else {
          // alert( 'Incorrect.' );
          radio.setAttribute( 'incorrect', '' );
          highlightCorrect = true;
        }

        var comfortRadioLabels =  Array.prototype.slice.call( this.shadowRoot.querySelectorAll( 'comfort-radio[name="' + questionNumber + '"] > label' ) );
           
        for ( var i = 0; i < comfortRadioLabels.length; i++ ) {
          // 0 = text, 1 = input, 2 = text
          comfortRadioLabels[i].childNodes[1].disabled = true;

          if ( highlightCorrect && ( comfortRadioLabels[i].textContent.trim() === correct.text ) ) {
            setTimeout( function ( i ) { 
              comfortRadioLabels[i].parentNode.setAttribute( 'correct', '' );
            }.bind( this, i ), 250 );
            // break;
          }
        }
      } );

      // $next.addEventListener( 'click', event => {
      //   console.log( 'document.forms', document.forms );
      // } );
    }
  };
  // })();
</script>